{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started HissDB is a SQLite3 frontend with a focus on ease-of-use and tight integration with Python syntax. Installation python3 -m pip install hissdb Usage Database Setup from hissdb import Database # make a new db or load one from an existing path db = Database ( 'test_location.db' ) # add some tables to the database users = db . create_table ( id = 'INTEGER PRIMARY KEY' , first_name = 'TEXT' , last_name = 'TEXT' , age = 'INTEGER' , ) posts = db . create_table ( user_id = 'INTEGER NOT NULL' , text = 'TEXT' , date = 'INTEGER' , foreign_keys = { 'user_id' : users . id }, ) Writing Data # inserting a row returns the new rowid jane_id = users . insert ( first_name = 'Jane' , last_name = 'Doe' ) john_id = users . insert ( first_name = 'John' , last_name = 'Doe' ) posts . insert ( user_id = john_id , date = 20210817 , text = \"I'm John Doe and this is my first post!\" ) # you can also insert many rows at once using a list or generator posts . insertmany ( cols = [ 'user_id' , 'date' , 'text' ], rows = [ ( jane_id , 20210814 , \"First!\" ), ( jane_id , 20210816 , \"The weather is nice today.\" ), ( jane_id , 20210817 , \"Do you ever post on the internet just so there's content?\" ), ], ) # you can update data based on matching criteria. # for instance, let's add a signature to each of Jane's posts posts . update ( text = posts . text + ' - ' + users . first_name , where = users . id == jane_id , ) # finally, we must write the changes to the file db . commit () Reading Data # get all users names = users . fetchall ( cols = [ 'first_name' , 'last_name' ]) assert names == [( 'Jane' , 'Doe' ), ( 'John' , 'Doe' )] # get a single column first_names = users . first_name . fetchall () assert first_names == [ 'Jane' , 'John' ] # easily write WHERE queries does = users . id . fetchall ( where = users . last_name == 'Doe' ) # an even simpler equivalent: does = users . id . fetchall ( last_name = 'Doe' ) assert does = [ 1 , 2 ] # a few methods like startswith() have been translated to SQL expressions users . insert ( first_name = 'Dave' , last_name = 'Guy' ) non_j_name = users . first_name . fetchone ( ~ users . first_name . startswith ( 'J' )) assert non_j_name == 'Dave' # you can construct all kinds of queries full_names = users . fetchall ( cols = ( users . first_name + ' ' + users . last_name )) assert full_names == [( 'Jane Doe' ,), ( 'John Doe' ,), ( 'Dave Guy' ,)] For more sample code using HissDB, see the tests . If you're looking for more detailed documentation, check out the library reference . \u2615 Buy me a coffee","title":"Getting Started"},{"location":"#getting-started","text":"HissDB is a SQLite3 frontend with a focus on ease-of-use and tight integration with Python syntax.","title":"Getting Started"},{"location":"#installation","text":"python3 -m pip install hissdb","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#database-setup","text":"from hissdb import Database # make a new db or load one from an existing path db = Database ( 'test_location.db' ) # add some tables to the database users = db . create_table ( id = 'INTEGER PRIMARY KEY' , first_name = 'TEXT' , last_name = 'TEXT' , age = 'INTEGER' , ) posts = db . create_table ( user_id = 'INTEGER NOT NULL' , text = 'TEXT' , date = 'INTEGER' , foreign_keys = { 'user_id' : users . id }, )","title":"Database Setup"},{"location":"#writing-data","text":"# inserting a row returns the new rowid jane_id = users . insert ( first_name = 'Jane' , last_name = 'Doe' ) john_id = users . insert ( first_name = 'John' , last_name = 'Doe' ) posts . insert ( user_id = john_id , date = 20210817 , text = \"I'm John Doe and this is my first post!\" ) # you can also insert many rows at once using a list or generator posts . insertmany ( cols = [ 'user_id' , 'date' , 'text' ], rows = [ ( jane_id , 20210814 , \"First!\" ), ( jane_id , 20210816 , \"The weather is nice today.\" ), ( jane_id , 20210817 , \"Do you ever post on the internet just so there's content?\" ), ], ) # you can update data based on matching criteria. # for instance, let's add a signature to each of Jane's posts posts . update ( text = posts . text + ' - ' + users . first_name , where = users . id == jane_id , ) # finally, we must write the changes to the file db . commit ()","title":"Writing Data"},{"location":"#reading-data","text":"# get all users names = users . fetchall ( cols = [ 'first_name' , 'last_name' ]) assert names == [( 'Jane' , 'Doe' ), ( 'John' , 'Doe' )] # get a single column first_names = users . first_name . fetchall () assert first_names == [ 'Jane' , 'John' ] # easily write WHERE queries does = users . id . fetchall ( where = users . last_name == 'Doe' ) # an even simpler equivalent: does = users . id . fetchall ( last_name = 'Doe' ) assert does = [ 1 , 2 ] # a few methods like startswith() have been translated to SQL expressions users . insert ( first_name = 'Dave' , last_name = 'Guy' ) non_j_name = users . first_name . fetchone ( ~ users . first_name . startswith ( 'J' )) assert non_j_name == 'Dave' # you can construct all kinds of queries full_names = users . fetchall ( cols = ( users . first_name + ' ' + users . last_name )) assert full_names == [( 'Jane Doe' ,), ( 'John Doe' ,), ( 'Dave Guy' ,)] For more sample code using HissDB, see the tests . If you're looking for more detailed documentation, check out the library reference . \u2615 Buy me a coffee","title":"Reading Data"},{"location":"library/","text":"Library Reference Database A pretty face for a sqlite3 database, with fancy access methods. If you have a Database called 'db', you can generally access any table in it via 'db.TABLE_NAME'. If the table name conflicts with an existing property or method, you can instead use 'db[TABLE_NAME]' as a fallback. __delitem__ ( self , item ) special Remove a Table from the database Source code in hissdb/db.py def __delitem__ ( self , item ): \"Remove a Table from the database\" self . execute ( f 'DROP TABLE { item } ' ) self . _tables . pop ( item ) __enter__ ( self ) special Context manager to handle connections to the database. If self._autocommit is True, then any changes are automatically committed at the close of the the 'with' statement. Source code in hissdb/db.py def __enter__ ( self ): \"\"\" Context manager to handle connections to the database. If self._autocommit is True, then any changes are automatically committed at the close of the the 'with' statement. \"\"\" self . connect ( reuse_existing = True ) return self __init__ ( self , path , autoconnect = True , autocommit = True , verbose = False ) special Database constructor. Parameters: Name Type Description Default path str the file path for a new or existing database, or ':memory:' for an in-memory database with no corresponding file required autoconnect bool whether to autoconnect to the database whenever a query requires it. If this is False, you must manually run the connect() method or keep all database operations inside a 'with' statement. True autocommit bool whether to write all changes to the database at the close of a 'with' statement. Note that even if this is True, you must manually run the commit() method if you make changes outside of a context manager. True verbose bool whether to print each SQL statement to the console as it is executed False Source code in hissdb/db.py def __init__ ( self , path : str , autoconnect : bool = True , autocommit : bool = True , verbose : bool = False , ): \"\"\" Database constructor. Arguments: path: the file path for a new or existing database, or ':memory:' for an in-memory database with no corresponding file autoconnect: whether to autoconnect to the database whenever a query requires it. If this is False, you must manually run the connect() method or keep all database operations inside a 'with' statement. autocommit: whether to write all changes to the database at the close of a 'with' statement. Note that even if this is True, you must manually run the commit() method if you make changes *outside* of a context manager. verbose: whether to print each SQL statement to the console as it is executed \"\"\" self . _path = Path ( path ) self . _verbose = verbose self . _autoconnect = autoconnect self . _autocommit = autocommit self . _connection = None self . _tables = {} if self . _path . exists (): self . connect () cur = self . execute ( 'SELECT sql FROM sqlite_schema' ) schema_rows = cur . fetchall () for schema_row in schema_rows : if not schema_row [ 0 ]: continue table = Table . _from_schema ( schema_row [ 0 ]) self . _tables [ table . _name ] = table table . _db = self if not self . _autoconnect : self . disconnect () __setattr__ ( self , attr , value ) special If value is a Table object, do CREATE TABLE. Otherwise, do normal setattr behavior. Source code in hissdb/db.py def __setattr__ ( self , attr : str , value ): \"\"\" If value is a Table object, do CREATE TABLE. Otherwise, do normal __setattr__ behavior. \"\"\" if type ( value ) is not Table : super () . __setattr__ ( attr , value ) return self . __setitem__ ( attr , value ) commit ( self ) Save recent changes to the database Source code in hissdb/db.py def commit ( self ): \"Save recent changes to the database\" self . connection . commit () connect ( self , reuse_existing = True ) Connect to the database. Returns a sqlite3 connection object, but you should not need to use it. Source code in hissdb/db.py def connect ( self , reuse_existing : bool = True ): \"\"\" Connect to the database. Returns a sqlite3 connection object, but you should not need to use it. \"\"\" if self . _connection and reuse_existing : return self . _connection else : self . _connection = sqlite3 . connect ( self . _path ) return self . _connection create_table ( self , name , columns = {}, foreign_keys = {}, primary_key = (), if_not_exist = False , ** kwargs ) Add a table to the database. Parameters: Name Type Description Default name str the name of the new table required columns dict a dict where each key is the name of a column, and each value contains the column constraints, e.g. {'id': 'INTEGER PRIMARY KEY', 'title': 'TEXT NOT NULL'}. {} foreign_keys dict a dict where each key is the name of a column in this table, and each value represents a column in another table. Values can be specified as Column objects or as strings like 'users(id)' or 'users.id'. {} primary_key tuple optional tuple with the names of multiple columns that should be combined to form the primary key. () Source code in hissdb/db.py def create_table ( self , name : str , columns : dict [ str , str ] = {}, foreign_keys : dict [ str , str ] = {}, primary_key : tuple [ str ] = (), if_not_exist : bool = False , ** kwargs , ) -> Table : \"\"\" Add a table to the database. Arguments: name: the name of the new table columns: a dict where each key is the name of a column, and each value contains the column constraints, e.g. {'id': 'INTEGER PRIMARY KEY', 'title': 'TEXT NOT NULL'}. foreign_keys: a dict where each key is the name of a column in this table, and each value represents a column in another table. Values can be specified as Column objects or as strings like 'users(id)' or 'users.id'. primary_key: optional tuple with the names of multiple columns that should be combined to form the primary key. \"\"\" if if_not_exist and name in self . _tables : return self . _tables [ name ] table = Table ( columns , foreign_keys , primary_key , ** kwargs ) self [ name ] = table return table disconnect ( self , commit = 'AUTO' ) Close the connection to the database. If commit is False, roll back any changes. If commit is True, commit them. If commit is 'AUTO', only commit if self._autocommit is True, but don't rollback either way. Source code in hissdb/db.py def disconnect ( self , commit : bool = 'AUTO' ): \"\"\" Close the connection to the database. If commit is False, roll back any changes. If commit is True, commit them. If commit is 'AUTO', only commit if self._autocommit is True, but don't rollback either way. \"\"\" if commit == True or ( commit == 'AUTO' and self . _autocommit ): self . commit () elif commit == False : self . rollback () self . connection . close () self . _connection = None drop_table ( self , name ) Delete the given table and its contents. Same as 'del self[name]' Source code in hissdb/db.py def drop_table ( self , name : str ): \"\"\" Delete the given table and its contents. Same as 'del self[name]' \"\"\" del self [ name ] execute ( self , statement , placeholders = {}, many = False ) Feed the given statement and placeholders to the execute() or executemany() method of this database's SQLite3 connection. If self._verbose is True, also print the executed statement. Source code in hissdb/db.py def execute ( self , statement : str , placeholders : dict = {}, many : bool = False , ): \"\"\" Feed the given statement and placeholders to the execute() or executemany() method of this database's SQLite3 connection. If self._verbose is True, also print the executed statement. \"\"\" if hasattr ( statement , 'placeholders' ): placeholders = copy ( placeholders ) placeholders . update ( statement . placeholders ) if many : func = self . connection . executemany else : func = self . connection . execute if self . _verbose : print ( f \"' { statement } '\" + ( f ', \\n { placeholders } ' if placeholders else '' ) ) return func ( statement , placeholders ) rollback ( self ) Undo all changes since the last commit Source code in hissdb/db.py def rollback ( self ): \"Undo all changes since the last commit\" self . connection . rollback () Table count ( self , where = None , ** kwargs ) Get the number of rows in the table, optionally restricted to those that meet the given criteria. Source code in hissdb/table.py def count ( self , where : Expression = None , ** kwargs ) -> int : \"\"\" Get the number of rows in the table, optionally restricted to those that meet the given criteria. \"\"\" return self . select ( count (), where , ** kwargs , ) . fetchone ()[ 0 ] delete ( self , where = None , ** kwargs ) Make and execute a Delete statement from this table, and return the number of rows deleted. Source code in hissdb/table.py def delete ( self , where : Expression = None , ** kwargs ) -> int : \"\"\" Make and execute a Delete statement from this table, and return the number of rows deleted. \"\"\" return Delete ( table = self , where = where , ** kwargs ) . execute () . rowcount fetchall ( self , cols = '*' , where = None , ** kwargs ) Make and execute a Select statement from this table, and return a list of all results. Source code in hissdb/table.py def fetchall ( self , cols = '*' , where = None , ** kwargs ): \"\"\" Make and execute a Select statement from this table, and return a list of all results. \"\"\" return self . select ( cols , where , ** kwargs ) . fetchall () fetchone ( self , cols = '*' , where = None , ** kwargs ) Make and execute a Select statement from this table, and return the first result. Source code in hissdb/table.py def fetchone ( self , cols = '*' , where = None , ** kwargs ): \"\"\" Make and execute a Select statement from this table, and return the first result. \"\"\" return self . select ( cols , where , ** kwargs ) . fetchone () insert ( self , row = {}, ** kwargs ) Make and execute an Insert statement into this table, and return the index of the of the new row. Source code in hissdb/table.py def insert ( self , row : dict = {}, ** kwargs ) -> int : \"\"\" Make and execute an Insert statement into this table, and return the index of the of the new row. \"\"\" return Insert ( table = self , row = row , ** kwargs ) . execute () . lastrowid insertmany ( self , cols , rows , or_ = None , ** kwargs ) Make and execute an InsertMany statement, and return the number of rows added. Source code in hissdb/table.py def insertmany ( self , cols : tuple [ Column ], rows : list [ tuple ], or_ : str = None , ** kwargs ) -> int : \"\"\" Make and execute an InsertMany statement, and return the number of rows added. \"\"\" return InsertMany ( table = self , cols = cols , rows = rows , or_ = or_ , ** kwargs ) . execute () . rowcount select ( self , cols = '*' , where = None , ** kwargs ) Make and execute a Select statement from this table, and return the resulting SQLite3 Cursor object. Source code in hissdb/table.py def select ( self , cols : list [ Column ] = '*' , where : Expression = None , ** kwargs , ) -> Cursor : \"\"\" Make and execute a Select statement from this table, and return the resulting SQLite3 Cursor object. \"\"\" statement = Select ( table = self , cols = cols , where = where , ** kwargs , ) return statement . execute () update ( self , updates = {}, where = None , ** kwargs ) Make and execute an Update statement from this table, and return the number of rows modified. Source code in hissdb/table.py def update ( self , updates : dict [ Column , Expression ] = {}, where : Expression = None , ** kwargs , ) -> int : \"\"\" Make and execute an Update statement from this table, and return the number of rows modified. \"\"\" return Update ( table = self , updates = updates , where = where , ** kwargs , ) . execute () . rowcount Column A Column is a reference to a column in a SQLite database. Because it is also an Expression, many of its logical operators are overridden so that you can build SQL Statements via Python logic like this: john_does = db.people.select(where= db.people.first_name == 'John' & db.people.last_name == 'Doe' ) For more information on this, see the Expression documentation. Attributes: Name Type Description cid column index number name name of the column type string containing the SQL datatype of this column notnull int representing whether the column disallows null vals dflt_value the column's default value pk int representing whether the column is a primary key __hash__ ( self ) special Return hash(self). Source code in hissdb/column.py def __hash__ ( self ): return hash ( str ( self )) __init__ ( self , constraints = None , table = None , name = None ) special Column object constructor. Parameters: Name Type Description Default constraints str a SQL expression defining this column, like 'TEXT NOT NULL' or 'INTEGER PRIMARY KEY' None table the table containing this column. If not provided, it will be set when the column is assigned to a table with Table. setattr or Table. setitem . None name str the name of this column. If not provided, it will be set when this column is assigned to a table. None Source code in hissdb/column.py def __init__ ( self , constraints : str = None , table = None , name : str = None , ): \"\"\" Column object constructor. Arguments: constraints: a SQL expression defining this column, like 'TEXT NOT NULL' or 'INTEGER PRIMARY KEY' table: the table containing this column. If not provided, it will be set when the column is assigned to a table with Table.__setattr__ or Table.__setitem__. name: the name of this column. If not provided, it will be set when this column is assigned to a table. \"\"\" self . _name = name self . _constraints = constraints if table : table [ name ] = self fetchall ( self , where = None , ** kwargs ) Convenience method to execute a Select statement targeting only this column, and return a list of the resulting values (rather than a list of one-item tuples). Source code in hissdb/column.py def fetchall ( self , where : Expression = None , ** kwargs ): \"\"\" Convenience method to execute a Select statement targeting only this column, and return a list of the resulting values (rather than a list of one-item tuples). \"\"\" vals = self . select ( where , ** kwargs ) . fetchall () return [ val [ 0 ] for val in vals ] fetchone ( self , where = None , ** kwargs ) Convenience method to execute a Select statement targeting only this column, and return the single resulting value (rather than a tuple with one item in it). Source code in hissdb/column.py def fetchone ( self , where : Expression = None , ** kwargs ): \"\"\" Convenience method to execute a Select statement targeting only this column, and return the single resulting value (rather than a tuple with one item in it). \"\"\" val = self . select ( where , ** kwargs ) . fetchone () return val [ 0 ] if val else None select ( self , where = None , ** kwargs ) Convenience method to execute a Select statement targeting only this column, and return the resulting Cursor object. Source code in hissdb/column.py def select ( self , where : Expression = None , ** kwargs ) -> Cursor : \"\"\" Convenience method to execute a Select statement targeting only this column, and return the resulting Cursor object. \"\"\" return self . _table . select ( cols = [ self ], where = where , ** kwargs , ) update ( self , new_value , where = None , ** kwargs ) Convenience method to execute an Update statement setting the value of this column, and return the number of rows modified. Source code in hissdb/column.py def update ( self , new_value : Expression , where : Expression = None , ** kwargs ): \"\"\" Convenience method to execute an Update statement setting the value of this column, and return the number of rows modified. \"\"\" return self . _table . update ( updates = { self : new_value }, where = where , ** kwargs ) Expressions Expressions are the building blocks of Statements. They provide two key features: First, they parameterize input values to avoid SQL injection; and second, they provide a set of methods and overloaded logical operators (e.g. '==', '&', or '+') that allow users to build compound Expressions with Python syntax. Attributes: Name Type Description tokens the results of parameterizing each of the provided args. Any item that is not an Expression, Table, or Column object will be converted to a placeholder unless it is in the _literals whitelist. placeholders a dictionary of parameters that would need to be provided to sqlite3.execute() if this expression were a Statement of its own necessary_tables a list of Tables this expression references desc property readonly Shortcut for use in ORDER BY clauses __abs__ ( self ) special SQLite ABS() function Source code in hissdb/expression.py def __abs__ ( self ): \"SQLite ABS() function\" return __class__ ( self , func = 'ABS' ) __add__ ( self , other ) special Add two numbers, concatenate two strings, or throw an error. Source code in hissdb/expression.py def __add__ ( self , other ): \"\"\" Add two numbers, concatenate two strings, or throw an error. \"\"\" othertype_ = type_ ( other ) selftype_ = type_ ( self ) if selftype_ in [ int , float ] and othertype_ in [ int , float ]: return __class__ ( self , '+' , other ) elif selftype_ is str and othertype_ is str : return __class__ ( self , '||' , other ) else : raise SyntaxError ( 'Addition is not supported between ' f ' { selftype_ } value \" { self } \" and { othertype_ } ' f 'value \" { other } \"' ) __init__ ( self , * args , * , func = None , prefix = None ) special Parameters: Name Type Description Default args the list of words or other values, in order, in the expression. Each one will be converted to a placeholder unless it is an Expression, Column, or Table object or is otherwise in the _literals whitelist. When the expression is converted to a string, the args (or their placeholders) will be joined with spaces. () func str the SQL function, if any, that the expression implements. If a func is provided, then the rendered expression will be enclosed in parentheses, preceded by the func string, and each arg will be separated by commas instead of spaces, to make them into function arguments rather than just words. None prefix str only relevant if func is provided. The prefix will be rendered just after the opening parentheses, before the first arg, with no separating comma. This is meant to allow for syntax like the \"DISTINCT\" argument for aggregate functions. None Source code in hissdb/expression.py def __init__ ( self , * args , func : str = None , prefix : str = None ): \"\"\" Arguments: args: the list of words or other values, in order, in the expression. Each one will be converted to a placeholder unless it is an Expression, Column, or Table object or is otherwise in the _literals whitelist. When the expression is converted to a string, the args (or their placeholders) will be joined with spaces. func: the SQL function, if any, that the expression implements. If a func is provided, then the rendered expression will be enclosed in parentheses, preceded by the func string, and each arg will be separated by commas instead of spaces, to make them into function arguments rather than just words. prefix: only relevant if func is provided. The prefix will be rendered just after the opening parentheses, before the first arg, with no separating comma. This is meant to allow for syntax like the \"DISTINCT\" argument for aggregate functions. \"\"\" self . placeholders = {} self . _necessary_tables = [] self . args = args self . tokens = [] self . func = func self . prefix = prefix for arg in args : # if issubclass ( arg . __class__ , __class__ ): self . placeholders . update ( arg . placeholders ) self . _necessary_tables += arg . _necessary_tables elif arg . __class__ . __module__ == 'hissdb.column' : self . _necessary_tables . append ( arg . _table ) elif arg . __class__ . __module__ == 'hissdb.table' : self . _necessary_tables . append ( arg ) elif arg is None : arg = 'NULL' elif type ( arg ) not in ( int , float , str ): raise SyntaxError ( f 'Couldn \\' t include \" { arg } \" in expression; ' f 'no support for objects of type: { type ( arg ) } ' ) elif arg not in self . _literals : placeholder = next_placeholder () self . placeholders [ placeholder [ 1 :]] = arg arg = placeholder self . tokens . append ( arg ) self . _necessary_tables = list ( set ( self . _necessary_tables )) __invert__ ( self ) special Return an expression that is True if and only if this one is not True. This works by replacing operators with their inverses (e.g. replacing '>' with '<='). When the expression to be inverted contains two sub-expressions joined with AND or OR, the sub-expressions are both inverted, and the AND is replaced with OR, or vice versa. Source code in hissdb/expression.py def __invert__ ( self ): \"\"\" Return an expression that is True if and only if this one is not True. This works by replacing operators with their inverses (e.g. replacing '>' with '<='). When the expression to be inverted contains two sub-expressions joined with AND or OR, the sub-expressions are both inverted, and the AND is replaced with OR, or vice versa. \"\"\" args = list ( copy ( self . args )) func = copy ( self . func ) if func : operator = func elif len ( args ) == 3 and type ( args [ 1 ]) is str : operator = args [ 1 ] elif len ( args ) == 7 and args [ 3 ] == 'OR' : operator = args [ 3 ] args = [ args [ 1 ], args [ 3 ], args [ 5 ]] else : operator = None opposites = ( ( 'LIKE' , 'NOT LIKE' ), ( 'IN' , 'NOT IN' ), ( 'BETWEEN' , 'NOT BETWEEN' ), ( 'IS' , 'IS NOT' ), ( 'EXISTS' , 'NOT EXISTS' ), ( '<>' , '=' ), ( '==' , '<>' ), ( '<' , '>=' ), ( '>' , '<=' ), ( 'AND' , 'OR' ), # also inverts sub-expressions, see below ) for a , b in opposites : if operator not in ( a , b ): continue new_op = a if operator == b else b if func : func = new_op else : args [ 1 ] = new_op break else : raise NotImplementedError ( f \"Unsure how to invert expression ' { str ( self ) } '\" ) if operator == 'OR' : return ~ args [ 0 ] & ~ args [ 2 ] elif operator == 'AND' : return ~ args [ 0 ] | ~ args [ 2 ] else : return __class__ ( * args , func = func ) __mod__ ( self , other ) special LIKE operator for strings, modulo operator otherwise Source code in hissdb/expression.py def __mod__ ( self , other ): \"LIKE operator for strings, modulo operator otherwise\" if type_ ( self ) is str : return __class__ ( self , 'LIKE' , other ) else : return __class__ ( self , '%' , other ) __str__ ( self ) special Text of the expression that will be inserted into a SQL statement, with placeholders to avoid injection Source code in hissdb/expression.py def __str__ ( self ): \"\"\" Text of the expression that will be inserted into a SQL statement, with placeholders to avoid injection \"\"\" joiner = ', ' if self . func else ' ' output = joiner . join ([ str ( t ) for t in self . tokens ]) output = output . replace ( '( ' , '(' ) . replace ( ' )' , ')' ) if self . prefix : output = f ' { self . prefix } { output } ' if self . func : return f ' { self . func } ( { output } )' else : return output avg ( self , distinct = False ) SQLite AVG() function Source code in hissdb/expression.py def avg ( self , distinct : bool = False ): \"SQLite AVG() function\" return __class__ ( self , func = 'AVG' , prefix = 'DISTINCT' if distinct else None ) ceil ( self ) SQLite CEIL() function Source code in hissdb/expression.py def ceil ( self ): \"SQLite CEIL() function\" return __class__ ( self , func = 'CEIL' ) count ( self , distinct = False ) SQLite COUNT() function Source code in hissdb/expression.py def count ( self , distinct : bool = False ): \"SQLite COUNT() function\" prefix = 'DISTINCT' if distinct else None return __class__ ( self , func = 'COUNT' , prefix = prefix ) exists ( self ) SQLite EXISTS() function Source code in hissdb/expression.py def exists ( self ): \"SQLite EXISTS() function\" return __class__ ( self , func = 'EXISTS' ) exp ( self ) SQLite EXP() function Source code in hissdb/expression.py def exp ( self ): \"SQLite EXP() function\" return __class__ ( self , func = 'EXP' ) floor ( self ) SQLite FLOOR() function Source code in hissdb/expression.py def floor ( self ): \"SQLite FLOOR() function\" return __class__ ( self , func = 'FLOOR' ) ln ( self ) SQLite LN() function Source code in hissdb/expression.py def ln ( self ): \"SQLite LN() function\" return __class__ ( self , func = 'LN' ) max ( self , distinct = False ) SQLite MAX() function Source code in hissdb/expression.py def max ( self , distinct : bool = False ): \"SQLite MAX() function\" return __class__ ( self , func = 'MAX' , prefix = 'DISTINCT' if distinct else None ) min ( self , distinct = False ) SQLite MIN() function Source code in hissdb/expression.py def min ( self , distinct : bool = False ): \"SQLite MIN() function\" return __class__ ( self , func = 'MIN' ) pow ( self , exponent ) SQLite POWER() function Source code in hissdb/expression.py def pow ( self , exponent : int ): \"SQLite POWER() function\" return __class__ ( self , exponent , func = 'POWER' ) render ( self ) Text of the expression with placeholders filled in Source code in hissdb/expression.py def render ( self ): \"Text of the expression with placeholders filled in\" text = str ( self ) for k , v in self . placeholders . items (): if type ( v ) is str : text = text . replace ( k , f \"' { v } '\" ) elif type ( v ) is int : text = text . replace ( k , str ( v )) text = text . replace ( k , str ( v )) return text round ( self ) SQLite ROUND() function Source code in hissdb/expression.py def round ( self ): \"SQLite ROUND() function\" return __class__ ( self , func = 'ROUND' ) sqrt ( self ) SQLite SQRT() function Source code in hissdb/expression.py def sqrt ( self ): \"SQLite SQRT() function\" return __class__ ( self , func = 'SQRT' ) BaseStatement base class that all Statements inherit from __init__ ( self , table , where = None , join = {}, order_by = None , limit = None , offset = None , autojoin = True , ** kwargs ) special BaseStatement class constructor. There should be no need for a user to use this directly rather than a subclass, but all subclasses accept the following arguments in their constructors. Parameters: Name Type Description Default table the Table object this statement relates to required where Expression an Expression object representing a WHERE clause in SQL. None join dict a dictionary where each key is a Column object to join on the condition that the corresponding Expression is met. {} order_by tuple a Column, an Expression object representing a virtual column, or a tuple containing multiple of either of those things. To sort descending, you can use the 'desc' property of any Column or Expression, e.g. \"order_by=db.users.first_name.desc\" None limit int an int or an Expression representing an int, setting the maximum number of rows to select or modify None offset int an int or an Expression representing an int, which sets which row to on. None autojoin bool whether HissDB should use the database's foreign key relationships to automatically join any tables that the statement requires. Defaults to True. True Source code in hissdb/statements.py def __init__ ( self , table , where : Expression = None , join : dict = {}, order_by : tuple [ Expression ] = None , limit : int = None , offset : int = None , autojoin : bool = True , ** kwargs , ): \"\"\" BaseStatement class constructor. There should be no need for a user to use this directly rather than a subclass, but all subclasses accept the following arguments in their constructors. Arguments: table: the Table object this statement relates to where: an Expression object representing a WHERE clause in SQL. join: a dictionary where each key is a Column object to join on the condition that the corresponding Expression is met. order_by: a Column, an Expression object representing a virtual column, or a tuple containing multiple of either of those things. To sort descending, you can use the 'desc' property of any Column or Expression, e.g. \"order_by=db.users.first_name.desc\" limit: an int or an Expression representing an int, setting the maximum number of rows to select or modify offset: an int or an Expression representing an int, which sets which row to on. autojoin: whether HissDB should use the database's foreign key relationships to automatically join any tables that the statement requires. Defaults to True. \"\"\" self . table = table self . where : Expression = where self . join = join self . order_by : tuple [ Expression ] = None self . limit : int = limit self . offset : int = offset self . autojoin : bool = autojoin self . unknown_kwargs = kwargs if order_by and type ( order_by ) not in [ list , tuple , set ]: self . order_by = tuple ( order_by ) else : self . order_by = order_by Insert SQL statement to insert a single row into a table __init__ ( self , table , row = {}, or_ = None , ** kwargs ) special Insert statement constructor. Any unknown keyword arguments will be added to the row dict. Parameters: Name Type Description Default table Table object to insert the row into required row dict dict of values representing the row to insert {} or_ str what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. None Source code in hissdb/statements.py def __init__ ( self , table , row : dict = {}, or_ : str = None , ** kwargs ): \"\"\" Insert statement constructor. Any unknown keyword arguments will be added to the row dict. Arguments: table: Table object to insert the row into row: dict of values representing the row to insert or_: what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. \"\"\" super () . __init__ ( table = table , ** kwargs ) self . or_ = or_ if self . unknown_kwargs : row = copy ( row ) row . update ( self . unknown_kwargs ) self . row = { k : Expression ( v ) for k , v in row . items ()} Select SQL statement to return some or all rows meeting given criteria __init__ ( self , table , cols = '*' , where = None , group_by = None , having = None , ** kwargs ) special Select statement constructor. Any unknown keyword arguments are interpreted as WHERE conditions constraining the value of a column in the given table. For instance, 'first_name=\"Jerry\"' is equivalent to 'where=[table].first_name == \"Jerry\"' Parameters: Name Type Description Default table the Table object from which to select values required cols list list of Column objects, or Expressions representing virtual columns, that the statement should select. For ease of use, columns can also be referenced via names rather than Column objects. '*' where Expression Expression constraining which rows to select None group_by list equivalent to SQL 'GROUP BY' clause None having Expression equivalent to SQL 'HAVING' clause None Source code in hissdb/statements.py def __init__ ( self , table , cols : list [ Column ] = '*' , where : Expression = None , group_by : list [ Column ] = None , having : Expression = None , ** kwargs ): \"\"\" Select statement constructor. Any unknown keyword arguments are interpreted as WHERE conditions constraining the value of a column in the given table. For instance, 'first_name=\"Jerry\"' is equivalent to 'where=[table].first_name == \"Jerry\"' Arguments: table: the Table object from which to select values cols: list of Column objects, or Expressions representing virtual columns, that the statement should select. For ease of use, columns can also be referenced via names rather than Column objects. where: Expression constraining which rows to select group_by: equivalent to SQL 'GROUP BY' clause having: equivalent to SQL 'HAVING' clause \"\"\" super () . __init__ ( table = table , where = where , ** kwargs ) self . raw_columns = cols for key , val in self . unknown_kwargs . items (): new_criteria = Expression ( self . table . _columns [ key ], '=' , val ) if self . where : self . where = self . where & new_criteria else : self . where = new_criteria if self . raw_columns == '*' or type ( self . raw_columns ) is Expression : self . columns = self . raw_columns else : self . columns = [ self . _resolve_column ( c ) for c in self . raw_columns ] if group_by : if type ( group_by ) in [ list , set , tuple ]: self . group_by = [ self . _resolve_column ( c ) for c in group_by ] else : self . group_by = self . _resolve_column ( group_by ) else : self . group_by = None self . having = having Update Delete SQL statement to delete some or all rows meeting given criteria InsertMany SQL statement to efficiently insert a list or generator of rows __init__ ( self , table , cols , rows , or_ = None , ** kwargs ) special InsertMany statement constructor. Parameters: Name Type Description Default cols tuple tuple of Column objects (or strings representing them) corresponding to the columns for which values will be provided. required rows list list or generator containing each row to insert. A row is a tuple whose values each represent the corresponding value in cols. required or_ str what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. None Source code in hissdb/statements.py def __init__ ( self , table , cols : tuple [ Column ], rows : list [ tuple ], or_ : str = None , ** kwargs ): \"\"\" InsertMany statement constructor. Arguments: cols: tuple of Column objects (or strings representing them) corresponding to the columns for which values will be provided. rows: list or generator containing each row to insert. A row is a tuple whose values each represent the corresponding value in cols. or_: what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. \"\"\" super () . __init__ ( table = table , ** kwargs ) self . or_ = or_ self . cols = [ self . _resolve_column ( col ) for col in cols ] self . rows = rows","title":"Library Reference"},{"location":"library/#library-reference","text":"","title":"Library Reference"},{"location":"library/#database","text":"A pretty face for a sqlite3 database, with fancy access methods. If you have a Database called 'db', you can generally access any table in it via 'db.TABLE_NAME'. If the table name conflicts with an existing property or method, you can instead use 'db[TABLE_NAME]' as a fallback.","title":"Database"},{"location":"library/#hissdb.db.Database.__delitem__","text":"Remove a Table from the database Source code in hissdb/db.py def __delitem__ ( self , item ): \"Remove a Table from the database\" self . execute ( f 'DROP TABLE { item } ' ) self . _tables . pop ( item )","title":"__delitem__()"},{"location":"library/#hissdb.db.Database.__enter__","text":"Context manager to handle connections to the database. If self._autocommit is True, then any changes are automatically committed at the close of the the 'with' statement. Source code in hissdb/db.py def __enter__ ( self ): \"\"\" Context manager to handle connections to the database. If self._autocommit is True, then any changes are automatically committed at the close of the the 'with' statement. \"\"\" self . connect ( reuse_existing = True ) return self","title":"__enter__()"},{"location":"library/#hissdb.db.Database.__init__","text":"Database constructor. Parameters: Name Type Description Default path str the file path for a new or existing database, or ':memory:' for an in-memory database with no corresponding file required autoconnect bool whether to autoconnect to the database whenever a query requires it. If this is False, you must manually run the connect() method or keep all database operations inside a 'with' statement. True autocommit bool whether to write all changes to the database at the close of a 'with' statement. Note that even if this is True, you must manually run the commit() method if you make changes outside of a context manager. True verbose bool whether to print each SQL statement to the console as it is executed False Source code in hissdb/db.py def __init__ ( self , path : str , autoconnect : bool = True , autocommit : bool = True , verbose : bool = False , ): \"\"\" Database constructor. Arguments: path: the file path for a new or existing database, or ':memory:' for an in-memory database with no corresponding file autoconnect: whether to autoconnect to the database whenever a query requires it. If this is False, you must manually run the connect() method or keep all database operations inside a 'with' statement. autocommit: whether to write all changes to the database at the close of a 'with' statement. Note that even if this is True, you must manually run the commit() method if you make changes *outside* of a context manager. verbose: whether to print each SQL statement to the console as it is executed \"\"\" self . _path = Path ( path ) self . _verbose = verbose self . _autoconnect = autoconnect self . _autocommit = autocommit self . _connection = None self . _tables = {} if self . _path . exists (): self . connect () cur = self . execute ( 'SELECT sql FROM sqlite_schema' ) schema_rows = cur . fetchall () for schema_row in schema_rows : if not schema_row [ 0 ]: continue table = Table . _from_schema ( schema_row [ 0 ]) self . _tables [ table . _name ] = table table . _db = self if not self . _autoconnect : self . disconnect ()","title":"__init__()"},{"location":"library/#hissdb.db.Database.__setattr__","text":"If value is a Table object, do CREATE TABLE. Otherwise, do normal setattr behavior. Source code in hissdb/db.py def __setattr__ ( self , attr : str , value ): \"\"\" If value is a Table object, do CREATE TABLE. Otherwise, do normal __setattr__ behavior. \"\"\" if type ( value ) is not Table : super () . __setattr__ ( attr , value ) return self . __setitem__ ( attr , value )","title":"__setattr__()"},{"location":"library/#hissdb.db.Database.commit","text":"Save recent changes to the database Source code in hissdb/db.py def commit ( self ): \"Save recent changes to the database\" self . connection . commit ()","title":"commit()"},{"location":"library/#hissdb.db.Database.connect","text":"Connect to the database. Returns a sqlite3 connection object, but you should not need to use it. Source code in hissdb/db.py def connect ( self , reuse_existing : bool = True ): \"\"\" Connect to the database. Returns a sqlite3 connection object, but you should not need to use it. \"\"\" if self . _connection and reuse_existing : return self . _connection else : self . _connection = sqlite3 . connect ( self . _path ) return self . _connection","title":"connect()"},{"location":"library/#hissdb.db.Database.create_table","text":"Add a table to the database. Parameters: Name Type Description Default name str the name of the new table required columns dict a dict where each key is the name of a column, and each value contains the column constraints, e.g. {'id': 'INTEGER PRIMARY KEY', 'title': 'TEXT NOT NULL'}. {} foreign_keys dict a dict where each key is the name of a column in this table, and each value represents a column in another table. Values can be specified as Column objects or as strings like 'users(id)' or 'users.id'. {} primary_key tuple optional tuple with the names of multiple columns that should be combined to form the primary key. () Source code in hissdb/db.py def create_table ( self , name : str , columns : dict [ str , str ] = {}, foreign_keys : dict [ str , str ] = {}, primary_key : tuple [ str ] = (), if_not_exist : bool = False , ** kwargs , ) -> Table : \"\"\" Add a table to the database. Arguments: name: the name of the new table columns: a dict where each key is the name of a column, and each value contains the column constraints, e.g. {'id': 'INTEGER PRIMARY KEY', 'title': 'TEXT NOT NULL'}. foreign_keys: a dict where each key is the name of a column in this table, and each value represents a column in another table. Values can be specified as Column objects or as strings like 'users(id)' or 'users.id'. primary_key: optional tuple with the names of multiple columns that should be combined to form the primary key. \"\"\" if if_not_exist and name in self . _tables : return self . _tables [ name ] table = Table ( columns , foreign_keys , primary_key , ** kwargs ) self [ name ] = table return table","title":"create_table()"},{"location":"library/#hissdb.db.Database.disconnect","text":"Close the connection to the database. If commit is False, roll back any changes. If commit is True, commit them. If commit is 'AUTO', only commit if self._autocommit is True, but don't rollback either way. Source code in hissdb/db.py def disconnect ( self , commit : bool = 'AUTO' ): \"\"\" Close the connection to the database. If commit is False, roll back any changes. If commit is True, commit them. If commit is 'AUTO', only commit if self._autocommit is True, but don't rollback either way. \"\"\" if commit == True or ( commit == 'AUTO' and self . _autocommit ): self . commit () elif commit == False : self . rollback () self . connection . close () self . _connection = None","title":"disconnect()"},{"location":"library/#hissdb.db.Database.drop_table","text":"Delete the given table and its contents. Same as 'del self[name]' Source code in hissdb/db.py def drop_table ( self , name : str ): \"\"\" Delete the given table and its contents. Same as 'del self[name]' \"\"\" del self [ name ]","title":"drop_table()"},{"location":"library/#hissdb.db.Database.execute","text":"Feed the given statement and placeholders to the execute() or executemany() method of this database's SQLite3 connection. If self._verbose is True, also print the executed statement. Source code in hissdb/db.py def execute ( self , statement : str , placeholders : dict = {}, many : bool = False , ): \"\"\" Feed the given statement and placeholders to the execute() or executemany() method of this database's SQLite3 connection. If self._verbose is True, also print the executed statement. \"\"\" if hasattr ( statement , 'placeholders' ): placeholders = copy ( placeholders ) placeholders . update ( statement . placeholders ) if many : func = self . connection . executemany else : func = self . connection . execute if self . _verbose : print ( f \"' { statement } '\" + ( f ', \\n { placeholders } ' if placeholders else '' ) ) return func ( statement , placeholders )","title":"execute()"},{"location":"library/#hissdb.db.Database.rollback","text":"Undo all changes since the last commit Source code in hissdb/db.py def rollback ( self ): \"Undo all changes since the last commit\" self . connection . rollback ()","title":"rollback()"},{"location":"library/#table","text":"","title":"Table"},{"location":"library/#hissdb.table.Table.count","text":"Get the number of rows in the table, optionally restricted to those that meet the given criteria. Source code in hissdb/table.py def count ( self , where : Expression = None , ** kwargs ) -> int : \"\"\" Get the number of rows in the table, optionally restricted to those that meet the given criteria. \"\"\" return self . select ( count (), where , ** kwargs , ) . fetchone ()[ 0 ]","title":"count()"},{"location":"library/#hissdb.table.Table.delete","text":"Make and execute a Delete statement from this table, and return the number of rows deleted. Source code in hissdb/table.py def delete ( self , where : Expression = None , ** kwargs ) -> int : \"\"\" Make and execute a Delete statement from this table, and return the number of rows deleted. \"\"\" return Delete ( table = self , where = where , ** kwargs ) . execute () . rowcount","title":"delete()"},{"location":"library/#hissdb.table.Table.fetchall","text":"Make and execute a Select statement from this table, and return a list of all results. Source code in hissdb/table.py def fetchall ( self , cols = '*' , where = None , ** kwargs ): \"\"\" Make and execute a Select statement from this table, and return a list of all results. \"\"\" return self . select ( cols , where , ** kwargs ) . fetchall ()","title":"fetchall()"},{"location":"library/#hissdb.table.Table.fetchone","text":"Make and execute a Select statement from this table, and return the first result. Source code in hissdb/table.py def fetchone ( self , cols = '*' , where = None , ** kwargs ): \"\"\" Make and execute a Select statement from this table, and return the first result. \"\"\" return self . select ( cols , where , ** kwargs ) . fetchone ()","title":"fetchone()"},{"location":"library/#hissdb.table.Table.insert","text":"Make and execute an Insert statement into this table, and return the index of the of the new row. Source code in hissdb/table.py def insert ( self , row : dict = {}, ** kwargs ) -> int : \"\"\" Make and execute an Insert statement into this table, and return the index of the of the new row. \"\"\" return Insert ( table = self , row = row , ** kwargs ) . execute () . lastrowid","title":"insert()"},{"location":"library/#hissdb.table.Table.insertmany","text":"Make and execute an InsertMany statement, and return the number of rows added. Source code in hissdb/table.py def insertmany ( self , cols : tuple [ Column ], rows : list [ tuple ], or_ : str = None , ** kwargs ) -> int : \"\"\" Make and execute an InsertMany statement, and return the number of rows added. \"\"\" return InsertMany ( table = self , cols = cols , rows = rows , or_ = or_ , ** kwargs ) . execute () . rowcount","title":"insertmany()"},{"location":"library/#hissdb.table.Table.select","text":"Make and execute a Select statement from this table, and return the resulting SQLite3 Cursor object. Source code in hissdb/table.py def select ( self , cols : list [ Column ] = '*' , where : Expression = None , ** kwargs , ) -> Cursor : \"\"\" Make and execute a Select statement from this table, and return the resulting SQLite3 Cursor object. \"\"\" statement = Select ( table = self , cols = cols , where = where , ** kwargs , ) return statement . execute ()","title":"select()"},{"location":"library/#hissdb.table.Table.update","text":"Make and execute an Update statement from this table, and return the number of rows modified. Source code in hissdb/table.py def update ( self , updates : dict [ Column , Expression ] = {}, where : Expression = None , ** kwargs , ) -> int : \"\"\" Make and execute an Update statement from this table, and return the number of rows modified. \"\"\" return Update ( table = self , updates = updates , where = where , ** kwargs , ) . execute () . rowcount","title":"update()"},{"location":"library/#column","text":"A Column is a reference to a column in a SQLite database. Because it is also an Expression, many of its logical operators are overridden so that you can build SQL Statements via Python logic like this: john_does = db.people.select(where= db.people.first_name == 'John' & db.people.last_name == 'Doe' ) For more information on this, see the Expression documentation. Attributes: Name Type Description cid column index number name name of the column type string containing the SQL datatype of this column notnull int representing whether the column disallows null vals dflt_value the column's default value pk int representing whether the column is a primary key","title":"Column"},{"location":"library/#hissdb.column.Column.__hash__","text":"Return hash(self). Source code in hissdb/column.py def __hash__ ( self ): return hash ( str ( self ))","title":"__hash__()"},{"location":"library/#hissdb.column.Column.__init__","text":"Column object constructor. Parameters: Name Type Description Default constraints str a SQL expression defining this column, like 'TEXT NOT NULL' or 'INTEGER PRIMARY KEY' None table the table containing this column. If not provided, it will be set when the column is assigned to a table with Table. setattr or Table. setitem . None name str the name of this column. If not provided, it will be set when this column is assigned to a table. None Source code in hissdb/column.py def __init__ ( self , constraints : str = None , table = None , name : str = None , ): \"\"\" Column object constructor. Arguments: constraints: a SQL expression defining this column, like 'TEXT NOT NULL' or 'INTEGER PRIMARY KEY' table: the table containing this column. If not provided, it will be set when the column is assigned to a table with Table.__setattr__ or Table.__setitem__. name: the name of this column. If not provided, it will be set when this column is assigned to a table. \"\"\" self . _name = name self . _constraints = constraints if table : table [ name ] = self","title":"__init__()"},{"location":"library/#hissdb.column.Column.fetchall","text":"Convenience method to execute a Select statement targeting only this column, and return a list of the resulting values (rather than a list of one-item tuples). Source code in hissdb/column.py def fetchall ( self , where : Expression = None , ** kwargs ): \"\"\" Convenience method to execute a Select statement targeting only this column, and return a list of the resulting values (rather than a list of one-item tuples). \"\"\" vals = self . select ( where , ** kwargs ) . fetchall () return [ val [ 0 ] for val in vals ]","title":"fetchall()"},{"location":"library/#hissdb.column.Column.fetchone","text":"Convenience method to execute a Select statement targeting only this column, and return the single resulting value (rather than a tuple with one item in it). Source code in hissdb/column.py def fetchone ( self , where : Expression = None , ** kwargs ): \"\"\" Convenience method to execute a Select statement targeting only this column, and return the single resulting value (rather than a tuple with one item in it). \"\"\" val = self . select ( where , ** kwargs ) . fetchone () return val [ 0 ] if val else None","title":"fetchone()"},{"location":"library/#hissdb.column.Column.select","text":"Convenience method to execute a Select statement targeting only this column, and return the resulting Cursor object. Source code in hissdb/column.py def select ( self , where : Expression = None , ** kwargs ) -> Cursor : \"\"\" Convenience method to execute a Select statement targeting only this column, and return the resulting Cursor object. \"\"\" return self . _table . select ( cols = [ self ], where = where , ** kwargs , )","title":"select()"},{"location":"library/#hissdb.column.Column.update","text":"Convenience method to execute an Update statement setting the value of this column, and return the number of rows modified. Source code in hissdb/column.py def update ( self , new_value : Expression , where : Expression = None , ** kwargs ): \"\"\" Convenience method to execute an Update statement setting the value of this column, and return the number of rows modified. \"\"\" return self . _table . update ( updates = { self : new_value }, where = where , ** kwargs )","title":"update()"},{"location":"library/#expressions","text":"Expressions are the building blocks of Statements. They provide two key features: First, they parameterize input values to avoid SQL injection; and second, they provide a set of methods and overloaded logical operators (e.g. '==', '&', or '+') that allow users to build compound Expressions with Python syntax. Attributes: Name Type Description tokens the results of parameterizing each of the provided args. Any item that is not an Expression, Table, or Column object will be converted to a placeholder unless it is in the _literals whitelist. placeholders a dictionary of parameters that would need to be provided to sqlite3.execute() if this expression were a Statement of its own necessary_tables a list of Tables this expression references","title":"Expressions"},{"location":"library/#hissdb.expression.Expression.desc","text":"Shortcut for use in ORDER BY clauses","title":"desc"},{"location":"library/#hissdb.expression.Expression.__abs__","text":"SQLite ABS() function Source code in hissdb/expression.py def __abs__ ( self ): \"SQLite ABS() function\" return __class__ ( self , func = 'ABS' )","title":"__abs__()"},{"location":"library/#hissdb.expression.Expression.__add__","text":"Add two numbers, concatenate two strings, or throw an error. Source code in hissdb/expression.py def __add__ ( self , other ): \"\"\" Add two numbers, concatenate two strings, or throw an error. \"\"\" othertype_ = type_ ( other ) selftype_ = type_ ( self ) if selftype_ in [ int , float ] and othertype_ in [ int , float ]: return __class__ ( self , '+' , other ) elif selftype_ is str and othertype_ is str : return __class__ ( self , '||' , other ) else : raise SyntaxError ( 'Addition is not supported between ' f ' { selftype_ } value \" { self } \" and { othertype_ } ' f 'value \" { other } \"' )","title":"__add__()"},{"location":"library/#hissdb.expression.Expression.__init__","text":"Parameters: Name Type Description Default args the list of words or other values, in order, in the expression. Each one will be converted to a placeholder unless it is an Expression, Column, or Table object or is otherwise in the _literals whitelist. When the expression is converted to a string, the args (or their placeholders) will be joined with spaces. () func str the SQL function, if any, that the expression implements. If a func is provided, then the rendered expression will be enclosed in parentheses, preceded by the func string, and each arg will be separated by commas instead of spaces, to make them into function arguments rather than just words. None prefix str only relevant if func is provided. The prefix will be rendered just after the opening parentheses, before the first arg, with no separating comma. This is meant to allow for syntax like the \"DISTINCT\" argument for aggregate functions. None Source code in hissdb/expression.py def __init__ ( self , * args , func : str = None , prefix : str = None ): \"\"\" Arguments: args: the list of words or other values, in order, in the expression. Each one will be converted to a placeholder unless it is an Expression, Column, or Table object or is otherwise in the _literals whitelist. When the expression is converted to a string, the args (or their placeholders) will be joined with spaces. func: the SQL function, if any, that the expression implements. If a func is provided, then the rendered expression will be enclosed in parentheses, preceded by the func string, and each arg will be separated by commas instead of spaces, to make them into function arguments rather than just words. prefix: only relevant if func is provided. The prefix will be rendered just after the opening parentheses, before the first arg, with no separating comma. This is meant to allow for syntax like the \"DISTINCT\" argument for aggregate functions. \"\"\" self . placeholders = {} self . _necessary_tables = [] self . args = args self . tokens = [] self . func = func self . prefix = prefix for arg in args : # if issubclass ( arg . __class__ , __class__ ): self . placeholders . update ( arg . placeholders ) self . _necessary_tables += arg . _necessary_tables elif arg . __class__ . __module__ == 'hissdb.column' : self . _necessary_tables . append ( arg . _table ) elif arg . __class__ . __module__ == 'hissdb.table' : self . _necessary_tables . append ( arg ) elif arg is None : arg = 'NULL' elif type ( arg ) not in ( int , float , str ): raise SyntaxError ( f 'Couldn \\' t include \" { arg } \" in expression; ' f 'no support for objects of type: { type ( arg ) } ' ) elif arg not in self . _literals : placeholder = next_placeholder () self . placeholders [ placeholder [ 1 :]] = arg arg = placeholder self . tokens . append ( arg ) self . _necessary_tables = list ( set ( self . _necessary_tables ))","title":"__init__()"},{"location":"library/#hissdb.expression.Expression.__invert__","text":"Return an expression that is True if and only if this one is not True. This works by replacing operators with their inverses (e.g. replacing '>' with '<='). When the expression to be inverted contains two sub-expressions joined with AND or OR, the sub-expressions are both inverted, and the AND is replaced with OR, or vice versa. Source code in hissdb/expression.py def __invert__ ( self ): \"\"\" Return an expression that is True if and only if this one is not True. This works by replacing operators with their inverses (e.g. replacing '>' with '<='). When the expression to be inverted contains two sub-expressions joined with AND or OR, the sub-expressions are both inverted, and the AND is replaced with OR, or vice versa. \"\"\" args = list ( copy ( self . args )) func = copy ( self . func ) if func : operator = func elif len ( args ) == 3 and type ( args [ 1 ]) is str : operator = args [ 1 ] elif len ( args ) == 7 and args [ 3 ] == 'OR' : operator = args [ 3 ] args = [ args [ 1 ], args [ 3 ], args [ 5 ]] else : operator = None opposites = ( ( 'LIKE' , 'NOT LIKE' ), ( 'IN' , 'NOT IN' ), ( 'BETWEEN' , 'NOT BETWEEN' ), ( 'IS' , 'IS NOT' ), ( 'EXISTS' , 'NOT EXISTS' ), ( '<>' , '=' ), ( '==' , '<>' ), ( '<' , '>=' ), ( '>' , '<=' ), ( 'AND' , 'OR' ), # also inverts sub-expressions, see below ) for a , b in opposites : if operator not in ( a , b ): continue new_op = a if operator == b else b if func : func = new_op else : args [ 1 ] = new_op break else : raise NotImplementedError ( f \"Unsure how to invert expression ' { str ( self ) } '\" ) if operator == 'OR' : return ~ args [ 0 ] & ~ args [ 2 ] elif operator == 'AND' : return ~ args [ 0 ] | ~ args [ 2 ] else : return __class__ ( * args , func = func )","title":"__invert__()"},{"location":"library/#hissdb.expression.Expression.__mod__","text":"LIKE operator for strings, modulo operator otherwise Source code in hissdb/expression.py def __mod__ ( self , other ): \"LIKE operator for strings, modulo operator otherwise\" if type_ ( self ) is str : return __class__ ( self , 'LIKE' , other ) else : return __class__ ( self , '%' , other )","title":"__mod__()"},{"location":"library/#hissdb.expression.Expression.__str__","text":"Text of the expression that will be inserted into a SQL statement, with placeholders to avoid injection Source code in hissdb/expression.py def __str__ ( self ): \"\"\" Text of the expression that will be inserted into a SQL statement, with placeholders to avoid injection \"\"\" joiner = ', ' if self . func else ' ' output = joiner . join ([ str ( t ) for t in self . tokens ]) output = output . replace ( '( ' , '(' ) . replace ( ' )' , ')' ) if self . prefix : output = f ' { self . prefix } { output } ' if self . func : return f ' { self . func } ( { output } )' else : return output","title":"__str__()"},{"location":"library/#hissdb.expression.Expression.avg","text":"SQLite AVG() function Source code in hissdb/expression.py def avg ( self , distinct : bool = False ): \"SQLite AVG() function\" return __class__ ( self , func = 'AVG' , prefix = 'DISTINCT' if distinct else None )","title":"avg()"},{"location":"library/#hissdb.expression.Expression.ceil","text":"SQLite CEIL() function Source code in hissdb/expression.py def ceil ( self ): \"SQLite CEIL() function\" return __class__ ( self , func = 'CEIL' )","title":"ceil()"},{"location":"library/#hissdb.expression.Expression.count","text":"SQLite COUNT() function Source code in hissdb/expression.py def count ( self , distinct : bool = False ): \"SQLite COUNT() function\" prefix = 'DISTINCT' if distinct else None return __class__ ( self , func = 'COUNT' , prefix = prefix )","title":"count()"},{"location":"library/#hissdb.expression.Expression.exists","text":"SQLite EXISTS() function Source code in hissdb/expression.py def exists ( self ): \"SQLite EXISTS() function\" return __class__ ( self , func = 'EXISTS' )","title":"exists()"},{"location":"library/#hissdb.expression.Expression.exp","text":"SQLite EXP() function Source code in hissdb/expression.py def exp ( self ): \"SQLite EXP() function\" return __class__ ( self , func = 'EXP' )","title":"exp()"},{"location":"library/#hissdb.expression.Expression.floor","text":"SQLite FLOOR() function Source code in hissdb/expression.py def floor ( self ): \"SQLite FLOOR() function\" return __class__ ( self , func = 'FLOOR' )","title":"floor()"},{"location":"library/#hissdb.expression.Expression.ln","text":"SQLite LN() function Source code in hissdb/expression.py def ln ( self ): \"SQLite LN() function\" return __class__ ( self , func = 'LN' )","title":"ln()"},{"location":"library/#hissdb.expression.Expression.max","text":"SQLite MAX() function Source code in hissdb/expression.py def max ( self , distinct : bool = False ): \"SQLite MAX() function\" return __class__ ( self , func = 'MAX' , prefix = 'DISTINCT' if distinct else None )","title":"max()"},{"location":"library/#hissdb.expression.Expression.min","text":"SQLite MIN() function Source code in hissdb/expression.py def min ( self , distinct : bool = False ): \"SQLite MIN() function\" return __class__ ( self , func = 'MIN' )","title":"min()"},{"location":"library/#hissdb.expression.Expression.pow","text":"SQLite POWER() function Source code in hissdb/expression.py def pow ( self , exponent : int ): \"SQLite POWER() function\" return __class__ ( self , exponent , func = 'POWER' )","title":"pow()"},{"location":"library/#hissdb.expression.Expression.render","text":"Text of the expression with placeholders filled in Source code in hissdb/expression.py def render ( self ): \"Text of the expression with placeholders filled in\" text = str ( self ) for k , v in self . placeholders . items (): if type ( v ) is str : text = text . replace ( k , f \"' { v } '\" ) elif type ( v ) is int : text = text . replace ( k , str ( v )) text = text . replace ( k , str ( v )) return text","title":"render()"},{"location":"library/#hissdb.expression.Expression.round","text":"SQLite ROUND() function Source code in hissdb/expression.py def round ( self ): \"SQLite ROUND() function\" return __class__ ( self , func = 'ROUND' )","title":"round()"},{"location":"library/#hissdb.expression.Expression.sqrt","text":"SQLite SQRT() function Source code in hissdb/expression.py def sqrt ( self ): \"SQLite SQRT() function\" return __class__ ( self , func = 'SQRT' )","title":"sqrt()"},{"location":"library/#basestatement","text":"base class that all Statements inherit from","title":"BaseStatement"},{"location":"library/#hissdb.statements.BaseStatement.__init__","text":"BaseStatement class constructor. There should be no need for a user to use this directly rather than a subclass, but all subclasses accept the following arguments in their constructors. Parameters: Name Type Description Default table the Table object this statement relates to required where Expression an Expression object representing a WHERE clause in SQL. None join dict a dictionary where each key is a Column object to join on the condition that the corresponding Expression is met. {} order_by tuple a Column, an Expression object representing a virtual column, or a tuple containing multiple of either of those things. To sort descending, you can use the 'desc' property of any Column or Expression, e.g. \"order_by=db.users.first_name.desc\" None limit int an int or an Expression representing an int, setting the maximum number of rows to select or modify None offset int an int or an Expression representing an int, which sets which row to on. None autojoin bool whether HissDB should use the database's foreign key relationships to automatically join any tables that the statement requires. Defaults to True. True Source code in hissdb/statements.py def __init__ ( self , table , where : Expression = None , join : dict = {}, order_by : tuple [ Expression ] = None , limit : int = None , offset : int = None , autojoin : bool = True , ** kwargs , ): \"\"\" BaseStatement class constructor. There should be no need for a user to use this directly rather than a subclass, but all subclasses accept the following arguments in their constructors. Arguments: table: the Table object this statement relates to where: an Expression object representing a WHERE clause in SQL. join: a dictionary where each key is a Column object to join on the condition that the corresponding Expression is met. order_by: a Column, an Expression object representing a virtual column, or a tuple containing multiple of either of those things. To sort descending, you can use the 'desc' property of any Column or Expression, e.g. \"order_by=db.users.first_name.desc\" limit: an int or an Expression representing an int, setting the maximum number of rows to select or modify offset: an int or an Expression representing an int, which sets which row to on. autojoin: whether HissDB should use the database's foreign key relationships to automatically join any tables that the statement requires. Defaults to True. \"\"\" self . table = table self . where : Expression = where self . join = join self . order_by : tuple [ Expression ] = None self . limit : int = limit self . offset : int = offset self . autojoin : bool = autojoin self . unknown_kwargs = kwargs if order_by and type ( order_by ) not in [ list , tuple , set ]: self . order_by = tuple ( order_by ) else : self . order_by = order_by","title":"__init__()"},{"location":"library/#insert","text":"SQL statement to insert a single row into a table","title":"Insert"},{"location":"library/#hissdb.statements.Insert.__init__","text":"Insert statement constructor. Any unknown keyword arguments will be added to the row dict. Parameters: Name Type Description Default table Table object to insert the row into required row dict dict of values representing the row to insert {} or_ str what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. None Source code in hissdb/statements.py def __init__ ( self , table , row : dict = {}, or_ : str = None , ** kwargs ): \"\"\" Insert statement constructor. Any unknown keyword arguments will be added to the row dict. Arguments: table: Table object to insert the row into row: dict of values representing the row to insert or_: what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. \"\"\" super () . __init__ ( table = table , ** kwargs ) self . or_ = or_ if self . unknown_kwargs : row = copy ( row ) row . update ( self . unknown_kwargs ) self . row = { k : Expression ( v ) for k , v in row . items ()}","title":"__init__()"},{"location":"library/#select","text":"SQL statement to return some or all rows meeting given criteria","title":"Select"},{"location":"library/#hissdb.statements.Select.__init__","text":"Select statement constructor. Any unknown keyword arguments are interpreted as WHERE conditions constraining the value of a column in the given table. For instance, 'first_name=\"Jerry\"' is equivalent to 'where=[table].first_name == \"Jerry\"' Parameters: Name Type Description Default table the Table object from which to select values required cols list list of Column objects, or Expressions representing virtual columns, that the statement should select. For ease of use, columns can also be referenced via names rather than Column objects. '*' where Expression Expression constraining which rows to select None group_by list equivalent to SQL 'GROUP BY' clause None having Expression equivalent to SQL 'HAVING' clause None Source code in hissdb/statements.py def __init__ ( self , table , cols : list [ Column ] = '*' , where : Expression = None , group_by : list [ Column ] = None , having : Expression = None , ** kwargs ): \"\"\" Select statement constructor. Any unknown keyword arguments are interpreted as WHERE conditions constraining the value of a column in the given table. For instance, 'first_name=\"Jerry\"' is equivalent to 'where=[table].first_name == \"Jerry\"' Arguments: table: the Table object from which to select values cols: list of Column objects, or Expressions representing virtual columns, that the statement should select. For ease of use, columns can also be referenced via names rather than Column objects. where: Expression constraining which rows to select group_by: equivalent to SQL 'GROUP BY' clause having: equivalent to SQL 'HAVING' clause \"\"\" super () . __init__ ( table = table , where = where , ** kwargs ) self . raw_columns = cols for key , val in self . unknown_kwargs . items (): new_criteria = Expression ( self . table . _columns [ key ], '=' , val ) if self . where : self . where = self . where & new_criteria else : self . where = new_criteria if self . raw_columns == '*' or type ( self . raw_columns ) is Expression : self . columns = self . raw_columns else : self . columns = [ self . _resolve_column ( c ) for c in self . raw_columns ] if group_by : if type ( group_by ) in [ list , set , tuple ]: self . group_by = [ self . _resolve_column ( c ) for c in group_by ] else : self . group_by = self . _resolve_column ( group_by ) else : self . group_by = None self . having = having","title":"__init__()"},{"location":"library/#update","text":"","title":"Update"},{"location":"library/#delete","text":"SQL statement to delete some or all rows meeting given criteria","title":"Delete"},{"location":"library/#insertmany","text":"SQL statement to efficiently insert a list or generator of rows","title":"InsertMany"},{"location":"library/#hissdb.statements.InsertMany.__init__","text":"InsertMany statement constructor. Parameters: Name Type Description Default cols tuple tuple of Column objects (or strings representing them) corresponding to the columns for which values will be provided. required rows list list or generator containing each row to insert. A row is a tuple whose values each represent the corresponding value in cols. required or_ str what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. None Source code in hissdb/statements.py def __init__ ( self , table , cols : tuple [ Column ], rows : list [ tuple ], or_ : str = None , ** kwargs ): \"\"\" InsertMany statement constructor. Arguments: cols: tuple of Column objects (or strings representing them) corresponding to the columns for which values will be provided. rows: list or generator containing each row to insert. A row is a tuple whose values each represent the corresponding value in cols. or_: what to do when the insert statement fails due to a table constraint. Options are 'ABORT', 'FAIL', 'IGNORE', 'REPLACE', and 'ROLLBACK'. \"\"\" super () . __init__ ( table = table , ** kwargs ) self . or_ = or_ self . cols = [ self . _resolve_column ( col ) for col in cols ] self . rows = rows","title":"__init__()"}]}